[[enhanced-ejb-configuration-deployment]]
= Enhanced EJB Configuration and Deployment

This page list the improvements done to EJB configuration and deployment on
Payara Server.

[[controlling-stateless-ejb-concurrent-instances]]
== Controlling Stateless EJB Concurrent Instances

_Since Payara Server 4.1.2.172_

In prior releases, it was not possible to control the maximum number of *_concurrent_*
Stateless EJB instances in Payara Server. It was, however, possible to control
the number of *_pooled_* Stateless EJB instances, as well as *_concurrent_* MDB
instances.

NOTE: These features were available in Oracle GlassFish Server 3.1 and earlier but not
in the GlassFish Open Source editions (3.1.2.x and 4.x).

It is now possible to limit concurrent Stateless EJB instances that are dispatched,
allowing fine-grained control of resources, limiting surface area for DDOS attacks
and making applications run more smoothly and efficiently.

The key difference is that previously it was not possible to limit the number of
concurrent threads dispatched for the same Stateless EJB, the only limit was the
number of pooled beans.  When the pool ran out, new EJB instances were created,
with no upper bound. In the current release, this upper bound can be established
so the maximum number of threads is not exceeded beyond this value.

These limits are controlled on a per-EJB basis, using `bean-pool` elements in the
`glassfish-ejb-jar.xml` deployment descriptor file:

[cols="4,10a",options="header"]
.`bean-pool` elements in `glassfish-ejb-jar.xml`
|===
|Element |Behaviour
|`<max-pool-size>`
|This element controls the maximum concurrent instances that are dispatched for
this EJB (number of threads).  The default is configured in the domain; this has
not changed from previous versions.
|`<max-wait-time-in-millis>`
|This element controls what to do when the number of requests exceeds the amount
of beans available in the pool.
Possible values of this element include:

* `-1` (_default_)
+
_Current behaviour is unchanged_: when the pooled number is exceeded, a new EJB
instance is created, there is no upper bound

* `0`
+
_This is new behaviour_: when the pooled number is exceeded, the request will
wait for a bean to free up in the pool. This effectively caps the number of threads
that are concurrently created for a this particular EJB request.

* Between `1` - `MAX_INTEGER`
+
This is the new behaviour, when the pool number is exceeded, the request will wait
for a bean to free up in the pool, up to the number of milliseconds specified here.
After this time has expired, a new EJB instance is created and dispatched, thus
the configured pool size acts as a soft upper bound, one that can be exceeded
once the timer has expired.

|`<steady-pool-size>`
|This element controls the *minimum* number of beans in the bean pool. This will
increase performance at the expense of memory footprint.
|===

Additionally, a new system property `fish.payara.ejb-container.max-wait-time-in-millis`
can be set to change the default global value of `<max-wait-time-in-millis>`
for *_all_* Stateless EJB bean pools.

IMPORTANT: Unless overridden in the deployment descriptor file, this will become
the new default value and can be used to cap the upper bound of all concurrent
invocations of any Stateless EJB pools.

[[example]]
=== Example

The following is a sample `glassfish-ejb-jar.xml` deployment descriptor that configures
2 EJBs with the settings mentioned beforehand.

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE glassfish-ejb-jar PUBLIC "-//GlassFish.org//DTD GlassFish Application Server 3.1 EJB 3.1//EN" "http://glassfish.org/dtds/glassfish-ejb-jar_3_1-1.dtd">
<glassfish-ejb-jar>
  <enterprise-beans>
    <ejb>
      <ejb-name>PooledStatelessBean</ejb-name>
      <bean-pool>
          <max-pool-size>1</max-pool-size>
          <max-wait-time-in-millis>0</max-wait-time-in-millis>
          <steady-pool-size>1</steady-pool-size>
      </bean-pool>
    </ejb>
    <ejb>
      <ejb-name>PooledMDB</ejb-name>
      <bean-pool>
          <max-pool-size>1</max-pool-size>
          <resize-quantity>1</resize-quantity>
      </bean-pool>
    </ejb>
  </enterprise-beans>
</glassfish-ejb-jar>
----

[[overwriting--the-module-name]]
== Overwriting the Module Name

_Since Payara Server 4.1.2.174_

When deploying an EJB-JAR module on Payara Server, the portable JNDI names for all scanned EJBs will be generated using the name of the module as specified on the _ejb-jar.xml_ deployment descriptor:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<ejb-jar xmlns = "http://java.sun.com/xml/ns/javaee"
         version = "3.1"
         xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation = "http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd">
    <module-name>MODULE_NAME</module-name>
</ejb-jar>
----

NOTE: If the name's not specified in the deployment descriptor, the specification states that the module name will be the same as the JAR artifact used to deploy it.

However, When deploying a JAR from an IDE (like **NetBeans** or **IntelliJ**), the IDE deploys to Payara Server using the asadmin `deploy` command, with the `--name` option specified. This will force the module to have the specified name over the name
defined in _ejb-jar.xml_. This is undesired because the IDE usually infers the module name from the name of the project or the JAR file and doesn't take the correct name of the module into account.

In the current release, an improvement has been implemented to solve this scenario:
The module name defined in the deployment descriptor will **always** be used even if it tries to be overridden using the `--name` option.

IMPORTANT: In the case you need to overwrite the name of the module when deploying the module, use the `--forceName` command option.

[[overwriting--the-application-name]]
=== Overwriting the Application Name

_Since Payara Server 4.1.2.182 and 5.182_

In the case of EAR artifacts, the portable JNDI names for all scanned EJBs will use the application name defined in the _application.xml_ deployment descriptor:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<application xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/application_7.xsd" version="7">
    <display-name>My Application</display-name>
    <application-name>APPLICATION_NAME</application-name>
    ...
</application>
----

NOTE: You can use the `--name` and `--forcename` deployment options to override the application name in a similar manner with what happens with EJB-JAR modules.

[[persistent-ejb-timers-with-hazelcast]]
== Persistent EJB Timers with the Domain Data Grid

_Since Payara Server 5.181_

{% set previewVersion = book.currentVersion %}

{% include "/fragments/tech-preview.adoc" %}

It is possible to persist an EJB Timer to the Domain Data Grid rather than to a database. The same feature is standard in link:/documentation/payara-micro/persistent-ejb-timers.adoc[Payara Micro].

Persisting an EJB Timer to the Domain Data Grid means that the Data Grid itself will store the timer details, preserving it even if the original instance leaves the cluster.

IMPORTANT: All stored timers are lost if the whole domain is stopped.

The Persistence service for EJB Timers can be set in the administration console by navigating to the *EJB Timer Service* tab in the EJB Container node of a configuration.

To use the Data Grid to store EJB Timers set the *Persistence Service* to _DataGrid_

image:/images/ejb/set-ejb-timer-persistence.png[Set EJB Persistence to Data Grid]

EJB Timers will be coordinated across a single deployment group and if an instance of the deployment group is stopped another instance in the same deployment group will take ownership of the timer and ensure it is fired.

CAUTION: Clustered Timer Firing Mode is NOT used in this version of Payara Server and is always "One Per Deployment Group"

It is also possible to set the `ejb-timer-service` using asadmin commands. To get the current state, run the following command:

[source, shell]
----
asadmin> get configs.config.${your-config}.ejb-container.ejb-timer-service
----

This will return the current state from the domain.xml, which by default should be something similar to the following:

[source, bash]
----
asadmin> get configs.config.server-config.ejb-container.ejb-timer-service

configs.config.server-config.ejb-container.ejb-timer-service.ejb-timer-service=Database
configs.config.server-config.ejb-container.ejb-timer-service.max-redeliveries=1
configs.config.server-config.ejb-container.ejb-timer-service.minimum-delivery-interval-in-millis=1000
configs.config.server-config.ejb-container.ejb-timer-service.redelivery-interval-internal-in-millis=5000
Command get executed successfully.
----

To persist to the DataGrid you need only change the value for `configs.config.server-config.ejb-container.ejb-timer-service.ejb-timer-service` to `DataGrid`. To do this, run the following `set` command:

[source, bash]
----
asadmin> set configs.config.server-config.ejb-container.ejb-timer-service.ejb-timer-service=DataGrid
----

WARNING: `set` commands are not dynamic. You will need to restart your domain to apply the changes.

[[timer-migration]]
=== Timer Migration

EJB Timers stored in the Domain Data Grid support timer migration between Instances in the same Deployment Group. You can migrate timers using the Administration console from the *Deployment Group* page. Timers can also be migrated between instances using asadmin commands like this:

[source, shell]
----
asadmin> migrate-timers --target server1 server2
----

Where `server1` is the active instance to migrate timers to and `server2` is the failed instance.

[[remote-ejb]]
=== Remote EJB using HTTP and thin client

_Since Payara Server 5.191_

{% set previewVersion = book.currentVersion %}

{% include "/fragments/tech-preview.adoc" %}

Payara and GlassFish have supported classic remote EJB since its inception. Classic remote EJB uses IIOP-RMI (Internet Inter-ORB Protocol Remote Method Invocation) for transport and https://omg.org/spec/SEC[CSIv2] (Common Secure Interoperability Protocol Version 2) for security. 

While feature rich, these protocols were not designed with firewalls, NAT, (private) clouds, docker and generally the Internet in mind. For these environments the requirements of the protocol, such as establishing independent connections back from the server to the client, are too troublesome. Practically speaking in these environments only one protocol really works, and that's HTTP(S).

Additionally, IIOP-RMI/CSIv2 also requires heavyweight client libs. In the case of Payara the client lib is almost as big as the entire server as it's essentially a special form of the ACC (Application Client Container). For HTTP(S) much smaller clients can be used, or even widely available HTTP agents such as wget or curl.

For these reasons Payara features an additional EJB remoting technology based on HTTP and using a thin client.  

NOTE: HTTP for EJB remoting in Payara is a completely different stack from the one IIOP-RMI/CSIv2 is using, and does not just replace the transport layer protocol in that existing stack.

WARNING: In the current version of this feature, not all remote EJB features are implemented yet.

HTTP for EJB remoting in Payara makes use of an endpoint on the Payara server, which by default has the path `/ejb-invoker`. This endpoint is disabled out of the box. It can be enabled using the `enable-ejb-invoker` asadmin command:

*Usage*::
`asadmin> enable-ejb-invoker "ejb-invoker"`

*Aim*::
Enabling the endpoint that listens to remote EJB calls over HTTP.

[[command-options]]
==== Command Options

[cols=",,,,",options="header",]
|=======================================================================
|Option |Shortcut |Description |Default |Mandatory
|`--target` |N/A |The instance or cluster to enable the endpoint on | server | No
|`--contextRoot` | (primary, no need to specify name) | Context root where an endpoint is listening for remote EJB calls | "ejb-invoker" | No
|=======================================================================

[[example]]
==== Example

The following command will enable the endpoint on the DAS

[source, shell]
----
asadmin > enable-ejb-invoker

----

Once enabled, the endpoint can be disabled again using the `disable-ejb-invoker` asadmin command:

*Usage*::
`asadmin> disable-ejb-invoker`

*Aim*::
Disabling the endpoint that listens to remote EJB calls over HTTP.

[[command-options-1]]
==== Command Options

[cols=",,,,",options="header",]
|=======================================================================
|Option |Shortcut |Description |Default |Mandatory
|`--target` |N/A |The instance or cluster to disable the endpoint on | server | No
|=======================================================================

[[example-1]]
==== Example

The following command will disable the endpoint on the DAS

[source, shell]
----
asadmin > disable-ejb-invoker

----

NOTE: The enable and disable commands deploy and undeploy an internal mini-war containing the endpoint. In this version this mini-war is shown in all overviews that show deployed applications once enabled.

You need to add a dependency to the Payara *thin client* to your client project to call remote EJBs using a type-safe
proxy (as is the norm for remote EJB programming): 

[source, xml]
----
<dependency>
    <groupId>fish.payara.extras</groupId>
    <artifactId>ejb-http-client</artifactId>
    <version>5.191</version>
</dependency>
----

To obtain a type-safe proxy for a remote EJB bean, the traditional approach via JDNI is used. An example is given below.

First, consider the following remote EJB interface:

[source, java]
----
@Remote
public interface BeanRemote {
    String method();
}
----

Second, consider a (secured) EJB implementing that interface and residing in an application called "test" on a Payara server listening to localhost:8080:

[source, java]
----
@Stateless
public class Bean implements BeanRemote, Serializable {

    private static final long serialVersionUID = 1L;

    @Override
    @RolesAllowed("g1")
    public String method() {
        return "method";
    }

}
----


Given the above, the following client code can be used to obtain a proxy to the `BeanRemote` bean and invoke a remote method on it:

[source, java]
----
import static javax.naming.Context.INITIAL_CONTEXT_FACTORY;
import static javax.naming.Context.PROVIDER_URL;
import static javax.naming.Context.SECURITY_CREDENTIALS;
import static javax.naming.Context.SECURITY_PRINCIPAL;

import java.util.Hashtable;
import javax.naming.Context;
import javax.naming.InitialContext;

Hashtable<String, String> environment = new Hashtable<String, String>();
environment.put(INITIAL_CONTEXT_FACTORY, "fish.payara.ejb.rest.client.RemoteEJBContextFactory");
environment.put(PROVIDER_URL, "https://localhost:8080/ejb-invoker");
environment.put(SECURITY_PRINCIPAL, "u1");
environment.put(SECURITY_CREDENTIALS, "p1");
        
InitialContext ejbRemoteContext = new InitialContext(environment);

BeanRemote beanRemote = (BeanRemote) ejbRemoteContext.lookup("java:global/test/Bean");

beanRemote.method() // returns "method"
----

If a remote bean is not secured, only the `INITIAL_CONTEXT_FACTORY` and `PROVIDER_URL` parameters are required.

WARNING: When accessing secured EJBs and passing the credential you *should* use only HTTPS, as the credential will be transferred in cleartext (not encrypted, only base64 encoded).

The proxy uses the JAX-RS/Jersey REST client builder to communicate with the remote server. The properties of this client builder can be customized via the JNDI environment properties. They are given below:

[cols="4,10,10a",options="header"]
.`JNDI customizatin options`
|===
|Property |Behaviour| Type
|`fish.payara.connectTimeout`
| The connect timeout. Value 0 represents infinity. Negative values are not allowed. Unit is microseconds.
| Number (from which it's Long value is taken) or String that can be converted to a Long.
|`fish.payara.readTimeout`
| The timeout to read a response. If the remote Payara doesn't respond within the defined time a ProcessingException is thrown with TimeoutException as the cause. Value 0 represents infinity. Negative values are not allowed. Unit is microseconds.
| Number (from which it's Long value is taken) or String that can be converted to a Long.
|`fish.payara.keyStore`
| The key store to be used by the proxy. The key store contains the private key as well as certificates with associated public keys.
| Instance of `java.security.KeyStore` or string representing fully qualified classname.
|`fish.payara.trustStore`
| The trust store to be used by the proxy. The trust store must contain the certificates that are needed to communicate with the Payara remote server.
| Instance of `java.security.KeyStore` or string representing fully qualified classname.
|`fish.payara.sslContext`
| The SSL context that will be used by the proxy for creating secured connections to the Payara remote server. This context *must* be fully initialized, including the trust- and key managers. Should not be used together with the `fish.payara.keyStore` and/or `fish.payara.trustStore` properties.
| Instance of `javax.net.ssl.SSLContext` or string representing fully qualified classname.
|`fish.payara.hostnameVerifier`
| The hostname verifier to be used by the proxy to verify the endpoint's hostname against the identification information of it.
| Instance of `javax.net.ssl.HostnameVerifier` or string representing fully qualified classname.
|`fish.payara.executorService`
| The executor service that will be used for executing asynchronous tasks. _(for future use)_
| Instance of `java.util.concurrent.ExecutorService` or string representing fully qualified classname.
|`fish.payara.scheduledExecutorService`
| The executor service that will be used for executing scheduled asynchronous tasks. _(for future use)_
| Instance of `java.util.concurrent.ScheduledExecutorService` or string representing fully qualified classname.
|`fish.payara.withConfig`
| The configuration for the internal JAX-RS/Jersey REST client.
| Instance of `javax.ws.rs.core.Configuration` or string representing fully qualified classname.
|===










