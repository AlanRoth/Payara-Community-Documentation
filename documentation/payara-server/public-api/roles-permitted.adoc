[[roles-permitted]]
= RolesPermitted Support

_Since Payara Server 4.1.2.182 and 5.182_

The Payara API provides a `@RolesPermitted` annotation that creates an authorisation interceptor for usage with CDI beans. This largely works in the same way as the `@RolesAllowed` common annotation, which in Java EE is primarily used by EJB.

[[usage]]
== Usage

The authorisation interceptor is defined through the `@RolesPermitted` annotation. Specifying this on an interceptable method of a CDI bean will make that method eligible for interception by the roles permitted interceptor. This interceptor will check that the caller of a method is any or all of the specified roles. If this holds, the call to the method proceeds. If not, an exception of type `CallerAccessException` is thrown.

The annotation can alternatively be placed at the class level of a CDI bean, in which case it will apply to all interceptable methods of that bean.

[[usage-example]]
=== Example

Here's an example that protects a single method:

[source, java]
----
@RequestScoped
public class TestRolesPermitted {

    @Inject
    Principal principal;

    @RolesPermitted({"payaraAdmin"})
    public String getUserName() {
        return principal.getName();
    }
}
----

See link:https://github.com/javaee-samples/vendoree-samples/tree/master/payara/rolesPermitted[this sample project] for a more detailed example.

[[configuration]]
== Configuration

The `@RolesPermitted` annotation has several configuration options.

They are detailed below.

.Configuration Options
|===
| Option | Required | Description | Requirements

| `value`
| true
| The roles which are allowed to access this method.
| -

| `semantics`
| no
| Whether accessing caller must be in any one of the given roles (`OR`) or all given roles (`AND`). Defaults to `OR`.
| -
|===

[[dynamic-roles]]
== Dynamic Roles

The `@RolesPermitted` annotation also allows to dynamically specify security roles permitted to access methods in an application
by using a predefined expression language (EL) as a dynamic role expression that interacts with the business 
method's parameters annotated with `javax.inject.Named` annotation.

[[usage-example]]
=== Example

Here’s an example that protects a single method by defining dynamically resolved roles name
and `@Named("customer")` annotation is used to define the parameter name and reference the 
parameter value in dynamic role expression.

[source, java]
----
@RolesPermitted("#{'CustomerCare_'.concat(customer.name)}")
public void updateCustomer(@Named("customer") Customer customer){
}
----

Multiple parameters can also be used in EL expression of dynamic security roles:

[source, java]
----
@RolesPermitted("#{self.findRole(customer, product)}")
public void updateCustomer(@Named("customer") Customer customer, @Named("product") Product product){
}

public String findRole(Customer customer, Product product) {
    return customer.type + "_" + product.model
}
----

If the parameter name not defined using `Named` annotation and the method have single parameter then `param` is used as default parameter name:

[source, java]
----
@RolesPermitted("#{'CustomerCare_'.concat(param.name)}")
public void updateCustomer(Customer customer){
}
----


== Extra Resources

See link:https://javaee.github.io/javaee-spec/javadocs/javax/annotation/security/RolesAllowed.html[@RolesAllowed] for the original annotation on which this annotation is based.